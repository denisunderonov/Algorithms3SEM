"""
ГРАФЫ — структура для представления связей между объектами.

ЧТО ТАКОЕ ГРАФ?
Граф = вершины (точки) + рёбра (линии между точками).
Пример: социальная сеть — люди это вершины, дружба это рёбра.

МАТРИЦА СМЕЖНОСТИ — способ хранения графа:
- Квадратная таблица размером N×N (N — количество вершин)
- matrix[i][j] = 1 означает "есть ребро из i в j"
- matrix[i][j] = 0 означает "нет ребра"

ОБХОДЫ ГРАФА — способы "пройтись" по всем вершинам:
1. BFS (Breadth-First Search) — обход в ширину
   Идём "слоями": сначала соседи стартовой вершины, потом соседи соседей и т.д.
   Использует ОЧЕРЕДЬ (FIFO — первым пришёл, первым ушёл)
   
2. DFS (Depth-First Search) — обход в глубину
   Идём "как можно глубже": выбираем соседа и сразу идём дальше от него
   Использует СТЕК (LIFO — последним пришёл, первым ушёл) или РЕКУРСИЮ

Примеры использования в `interactive_graph.py`.
"""
from collections import deque  # Очередь для BFS
from typing import List, Optional


class Graph:
    """
    Граф, представленный матрицей смежности.
    
    Представление:
    - Вершины пронумерованы от 0 до n-1
    - matrix[u][v] != 0 означает "есть ребро из u в v"
    - Если граф неориентированный, matrix симметрична (matrix[u][v] == matrix[v][u])
    
    Пример неориентированного графа (4 вершины):
    matrix = [
        [0, 1, 1, 0],  # вершина 0 соединена с 1 и 2
        [1, 0, 0, 1],  # вершина 1 соединена с 0 и 3
        [1, 0, 0, 1],  # вершина 2 соединена с 0 и 3
        [0, 1, 1, 0]   # вершина 3 соединена с 1 и 2
    ]
    """

    def __init__(self, matrix: List[List[int]], directed: bool = False):
        """
        Создание графа из матрицы смежности.
        
        Параметры:
            matrix: квадратная матрица N×N (список списков)
            directed: True для ориентированного графа, False для неориентированного
        """
        # Проверяем: матрица должна быть квадратной и не пустой
        if not matrix or any(len(row) != len(matrix) for row in matrix):
            raise ValueError("Матрица смежности должна быть квадратной и не пустой")
        
        # Сохраняем матрицу
        self.matrix = matrix
        # Запоминаем количество вершин
        self.n = len(matrix)
        # Запоминаем тип графа
        self.directed = directed

    def neighbors(self, v: int) -> List[int]:
        """
        Получить список всех соседей вершины v.
        
        Сосед — это вершина, в которую можно перейти по ребру из v.
        Проверяем строку v в матрице: если matrix[v][i] != 0, то i — сосед.
        
        Возвращает: список номеров вершин-соседей
        Сложность: O(n) — проверяем всю строку матрицы
        """
        # Сначала проверяем, что номер вершины корректный (от 0 до n-1)
        # Если нет — выбрасываем ошибку, чтобы не работать с несуществующей вершиной
        if not (0 <= v < self.n):
            raise IndexError("некорректный индекс вершины")
        
        # Теперь ищем всех соседей вершины v
        # Смотрим на строку v в матрице смежности
        # Проходим по всем столбцам (другим вершинам) с помощью enumerate
        # enumerate даёт нам пары (индекс, значение): (0, matrix[v][0]), (1, matrix[v][1]) и т.д.
        # Если значение != 0, значит между v и i есть ребро, добавляем i в список
        return [i for i, val in enumerate(self.matrix[v]) if val]

    def bfs(self, start: int) -> List[int]:
        """
        Обход в ширину (Breadth-First Search).
        
        АЛГОРИТМ (простыми словами):
        1. Начинаем со стартовой вершины
        2. Добавляем её в очередь и помечаем как посещённую
        3. Пока очередь не пуста:
           - Берём первую вершину из очереди
           - Записываем её в результат
           - Смотрим всех её соседей
           - Тех, кто ещё не посещён, помечаем и добавляем в очередь
        
        ЗАЧЕМ НУЖЕН BFS?
        - Найти кратчайший путь в невзвешенном графе
        - Обойти граф "по уровням" (сначала близкие вершины, потом дальние)
        
        ПРИМЕР: Граф 0-1-2-3 (линия)
        BFS от 0: [0, 1, 2, 3] — идём последовательно
        
        Сложность: O(n + m), где n — вершины, m — рёбра
        Возвращает: список вершин в порядке посещения
        """
        # Проверяем, что стартовая вершина существует (от 0 до n-1)
        # Если start неправильный — выбрасываем ошибку
        if not (0 <= start < self.n):
            raise IndexError("start вне диапазона вершин")
        
        # Создаём массив для отметки посещённых вершин
        # Изначально все False (никто ещё не посещён)
        # visited[i] = True означает "вершину i мы уже обработали"
        visited = [False] * self.n
        
        # Список для сохранения порядка обхода
        # Сюда будем добавлять вершины по мере их посещения
        order: List[int] = []
        
        # Создаём очередь для BFS (deque = двусторонняя очередь)
        # В BFS важно соблюдать порядок FIFO (First In First Out)
        # Первым пришёл — первым ушёл (как очередь в магазине)
        q = deque()
        
        # СТАРТУЕМ: помечаем начальную вершину как посещённую
        visited[start] = True
        # И добавляем её в очередь — с неё начнётся обход
        q.append(start)
        
        # Главный цикл BFS: работаем, пока в очереди есть вершины
        while q:
            # Берём первую вершину из очереди (это ключевой момент BFS!)
            # popleft() удаляет и возвращает элемент слева (из начала очереди)
            # Это обеспечивает обход "в ширину" — сначала обрабатываем близкие вершины
            v = q.popleft()
            
            # Записываем текущую вершину в порядок обхода
            # Это значит "мы сейчас обрабатываем вершину v"
            order.append(v)
            
            # Теперь смотрим всех соседей текущей вершины v
            # neighbors(v) вернёт список всех вершин, связанных с v
            for u in self.neighbors(v):
                # Проверяем: если сосед u ещё не посещён
                if not visited[u]:
                    # Помечаем его как посещённого (чтобы не добавить дважды)
                    visited[u] = True
                    # Добавляем в конец очереди
                    # Он будет обработан позже, после всех текущих вершин в очереди
                    # Это создаёт эффект "обхода по уровням"
                    q.append(u)
        
        # Возвращаем порядок, в котором мы посетили все вершины
        return order

    def dfs(self, start: int) -> List[int]:
        """
        Обход в глубину (Depth-First Search) — ИТЕРАТИВНАЯ версия со СТЕКОМ.
        
        АЛГОРИТМ:
        1. Кладём стартовую вершину в стек
        2. Пока стек не пуст:
           - Берём вершину из верха стека (pop)
           - Если уже посещена — пропускаем
           - Помечаем как посещённую, записываем
           - Добавляем всех непосещённых соседей в стек
        
        ЗАЧЕМ НУЖЕН DFS?
        - Поиск путей в лабиринте
        - Проверка связности графа
        - Топологическая сортировка
        
        Сложность: O(n + m), где n — вершины, m — рёбра
        Возвращает: список вершин в порядке посещения
        """
        # Проверяем корректность стартовой вершины
        if not (0 <= start < self.n):
            raise IndexError("start вне диапазона вершин")
        
        # Массив посещённых вершин (все изначально False)
        visited = [False] * self.n
        # Порядок обхода (будем добавлять вершины сюда)
        order: List[int] = []
        
        # Стек для DFS (используем обычный список Python)
        # СТЕК = LIFO (Last In First Out) — последним пришёл, первым ушёл
        stack = [start]
        
        # Главный цикл: работаем, пока стек не пуст
        while stack:
            # Берём вершину с ВЕРХА стека (последнюю добавленную)
            # pop() удаляет и возвращает последний элемент
            # Это ключевое отличие от BFS, где мы берём из НАЧАЛА очереди
            v = stack.pop()
            
            # Если вершина уже была посещена — пропускаем её
            if visited[v]:
                continue
            
            # Помечаем вершину как посещённую
            visited[v] = True
            # Записываем в порядок обхода
            order.append(v)
            
            # Теперь добавляем всех непосещённых соседей в стек
            # ВАЖНО: добавляем в ОБРАТНОМ порядке, чтобы меньшие индексы обрабатывались первыми
            neighbors = self.neighbors(v)
            for u in reversed(neighbors):
                if not visited[u]:
                    stack.append(u)
        
        # Возвращаем порядок посещения
        return order

    def dfs_recursive(self, start: int) -> List[int]:
        """
        Обход в глубину (DFS) — РЕКУРСИВНАЯ версия (альтернативная реализация).
        
        АЛГОРИТМ:
        1. Начинаем со стартовой вершины
        2. Помечаем её как посещённую и записываем
        3. Для каждого непосещённого соседа вызываем DFS рекурсивно
        4. Идём "в глубину" до упора, потом возвращаемся
        
        Сложность: O(n + m)
        """
        if not (0 <= start < self.n):
            raise IndexError("start вне диапазона вершин")
        
        visited = [False] * self.n
        order: List[int] = []

        def _dfs(v: int) -> None:
            visited[v] = True
            order.append(v)
            
            neighbors = self.neighbors(v)
            for u in neighbors:
                if not visited[u]:
                    _dfs(u)

        _dfs(start)
        return order

    def display(self) -> None:
        """Печать матрицы смежности в читаемом виде."""
        print("Матрица смежности:")
        for row in self.matrix:
            print(" ".join(str(x) for x in row))


def input_graph():
    """Интерактивный ввод графа пользователем."""
    print("=" * 50)
    print("ВВОД ГРАФА")
    print("=" * 50)
    
    # Выбор: пример или свой граф
    print("\n1 - Использовать пример графа (6 вершин)")
    print("2 - Ввести свой граф")
    choice = input("Выберите вариант (1 или 2): ").strip()
    
    if choice == "1":
        # Пример графа
        mat = [
            [0, 1, 1, 0, 0, 0],
            [1, 0, 0, 1, 1, 0],
            [1, 0, 0, 0, 1, 0],
            [0, 1, 0, 0, 1, 1],
            [0, 1, 1, 1, 0, 0],
            [0, 0, 0, 1, 0, 0],
        ]
        directed = False
        print("\nИспользуется пример неориентированного графа из 6 вершин")
    else:
        # Ввод своего графа
        n = int(input("\nВведите количество вершин: "))
        
        print("\nГраф ориентированный? (да/нет): ", end="")
        dir_input = input().strip().lower()
        directed = dir_input in ['да', 'yes', 'y', 'д']
        
        print(f"\nВведите матрицу смежности {n}x{n}")
        print("(каждая строка — числа через пробел, 0 = нет ребра, 1 = есть ребро):")
        print("Пример для 3 вершин:")
        print("  0 1 0")
        print("  1 0 1")
        print("  0 1 0")
        print()
        
        mat = []
        for i in range(n):
            while True:
                try:
                    row_input = input(f"Строка {i}: ").strip()
                    row = list(map(int, row_input.split()))
                    if len(row) != n:
                        print(f"  Ошибка: нужно ввести {n} чисел. Попробуйте снова.")
                        continue
                    mat.append(row)
                    break
                except ValueError:
                    print("  Ошибка: введите числа через пробел. Попробуйте снова.")
    
    return mat, directed


if __name__ == "__main__":
    print("ЛР17: ОБХОД ГРАФА (BFS и DFS)")
    print("-" * 50)
    
    # Граф: 0 соседи 1,2; 1 соседи 0,3; 2 соседи 0,3,4; 3 соседи 0,1,2,4; 4 соседи 2,3
    
    mat = [
        [0, 1, 1, 0, 0],  # 0 связана с 1, 2
        [1, 0, 0, 1, 0],  # 1 связана с 0, 3
        [1, 0, 0, 1, 1],  # 2 связана с 0, 3, 4
        [0, 1, 1, 0, 1],  # 3 связана с 1, 2, 4
        [0, 0, 1, 1, 0],  # 4 связана с 2, 3
    ]
    directed = False
    
    g = Graph(mat, directed=directed)
    start = 0
    
    print(f"\nBFS (обход в ширину) из вершины {start}:")
    print("Используем очередь, обходим по уровням")
    bfs_order = g.bfs(start)
    print(f"Результат: {' -> '.join(map(str, bfs_order))}")
    
    print(f"\nDFS (обход в глубину) из вершины {start}:")
    print("Используем СТЕК (LIFO), идём вглубь до конца")
    dfs_order = g.dfs(start)
    print(f"Результат: {' -> '.join(map(str, dfs_order))}")
    
    print("\nРазница:")
    print("  BFS использует ОЧЕРЕДЬ (FIFO): обходим по уровням")
    print("  DFS использует СТЕК (LIFO): идём в глубину по одному пути")
    print()
