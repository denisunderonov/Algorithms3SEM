"""
ГРАФЫ — структура для представления связей между объектами.

ЧТО ТАКОЕ ГРАФ?
Граф = вершины (точки) + рёбра (линии между точками).
Пример: социальная сеть — люди это вершины, дружба это рёбра.

МАТРИЦА СМЕЖНОСТИ — способ хранения графа:
- Квадратная таблица размером N×N (N — количество вершин)
- matrix[i][j] = 1 означает "есть ребро из i в j"
- matrix[i][j] = 0 означает "нет ребра"

ОБХОДЫ ГРАФА — способы "пройтись" по всем вершинам:
1. BFS (Breadth-First Search) — обход в ширину
   Идём "слоями": сначала соседи стартовой вершины, потом соседи соседей и т.д.
   Использует ОЧЕРЕДЬ (FIFO — первым пришёл, первым ушёл)
   
2. DFS (Depth-First Search) — обход в глубину
   Идём "как можно глубже": выбираем соседа и сразу идём дальше от него
   Использует СТЕК (LIFO — последним пришёл, первым ушёл) или РЕКУРСИЮ

Примеры использования в `interactive_graph.py`.
"""
from collections import deque  # Очередь для BFS
from typing import List, Optional


class Graph:
    """
    Граф, представленный матрицей смежности.
    
    Представление:
    - Вершины пронумерованы от 0 до n-1
    - matrix[u][v] != 0 означает "есть ребро из u в v"
    - Если граф неориентированный, matrix симметрична (matrix[u][v] == matrix[v][u])
    
    Пример неориентированного графа (4 вершины):
    matrix = [
        [0, 1, 1, 0],  # вершина 0 соединена с 1 и 2
        [1, 0, 0, 1],  # вершина 1 соединена с 0 и 3
        [1, 0, 0, 1],  # вершина 2 соединена с 0 и 3
        [0, 1, 1, 0]   # вершина 3 соединена с 1 и 2
    ]
    """

    def __init__(self, matrix: List[List[int]], directed: bool = False):
        """
        Создание графа из матрицы смежности.
        
        Параметры:
            matrix: квадратная матрица N×N (список списков)
            directed: True для ориентированного графа, False для неориентированного
        """
        # Проверяем: матрица должна быть квадратной и не пустой
        if not matrix or any(len(row) != len(matrix) for row in matrix):
            raise ValueError("Матрица смежности должна быть квадратной и не пустой")
        
        # Сохраняем матрицу
        self.matrix = matrix
        # Запоминаем количество вершин
        self.n = len(matrix)
        # Запоминаем тип графа
        self.directed = directed

    def neighbors(self, v: int) -> List[int]:
        """
        Получить список всех соседей вершины v.
        
        Сосед — это вершина, в которую можно перейти по ребру из v.
        Проверяем строку v в матрице: если matrix[v][i] != 0, то i — сосед.
        
        Возвращает: список номеров вершин-соседей
        Сложность: O(n) — проверяем всю строку матрицы
        """
        # Проверяем корректность номера вершины
        if not (0 <= v < self.n):
            raise IndexError("некорректный индекс вершины")
        
        # Проходим по строке v матрицы и собираем номера соседей
        # i — номер столбца (потенциальный сосед)
        # val — значение matrix[v][i] (есть ли ребро)
        return [i for i, val in enumerate(self.matrix[v]) if val]

    def bfs(self, start: int) -> List[int]:
        """
        Обход в ширину (Breadth-First Search).
        
        АЛГОРИТМ (простыми словами):
        1. Начинаем со стартовой вершины
        2. Добавляем её в очередь и помечаем как посещённую
        3. Пока очередь не пуста:
           - Берём первую вершину из очереди
           - Записываем её в результат
           - Смотрим всех её соседей
           - Тех, кто ещё не посещён, помечаем и добавляем в очередь
        
        ЗАЧЕМ НУЖЕН BFS?
        - Найти кратчайший путь в невзвешенном графе
        - Обойти граф "по уровням" (сначала близкие вершины, потом дальние)
        
        ПРИМЕР: Граф 0-1-2-3 (линия)
        BFS от 0: [0, 1, 2, 3] — идём последовательно
        
        Сложность: O(n + m), где n — вершины, m — рёбра
        Возвращает: список вершин в порядке посещения
        """
        # Проверяем корректность стартовой вершины
        if not (0 <= start < self.n):
            raise IndexError("start вне диапазона вершин")
        
        # Массив для отметки посещённых вершин (изначально все False)
        visited = [False] * self.n
        # Список для записи порядка обхода
        order: List[int] = []
        # Очередь для BFS (FIFO — первым пришёл, первым ушёл)
        q = deque()
        
        # Стартуем: помечаем начальную вершину и добавляем в очередь
        visited[start] = True
        q.append(start)
        
        # Главный цикл: пока в очереди есть вершины
        while q:
            # Берём первую вершину из очереди (это важно для BFS!)
            v = q.popleft()
            # Записываем её в порядок обхода
            order.append(v)
            
            # Смотрим всех соседей текущей вершины
            for u in self.neighbors(v):
                # Если сосед ещё не посещён
                if not visited[u]:
                    # Помечаем его как посещённого
                    visited[u] = True
                    # Добавляем в конец очереди (будем обрабатывать позже)
                    q.append(u)
        # Возвращаем порядок обхода
        return order

    def dfs(self, start: int) -> List[int]:
        """
        Обход в глубину (Depth-First Search) — РЕКУРСИВНАЯ версия.
        
        АЛГОРИТМ:
        1. Начинаем со стартовой вершины
        2. Помечаем её как посещённую и записываем
        3. Для каждого непосещённого соседа вызываем DFS рекурсивно
        4. Идём "в глубину" до упора, потом возвращаемся
        
        ЗАЧЕМ НУЖЕН DFS?
        - Поиск путей в лабиринте
        - Проверка связности графа
        - Топологическая сортировка
        
        ПРИМЕР: Граф 0-1-2-3 (линия)
        DFS от 0: [0, 1, 2, 3] — идём по цепочке до конца
        
        Сложность: O(n + m)
        Возвращает: список вершин в порядке посещения
        """
        if not (0 <= start < self.n):
            raise IndexError("start вне диапазона вершин")
        
        # Массив посещённых вершин
        visited = [False] * self.n
        # Порядок обхода
        order: List[int] = []

        def _dfs(v: int) -> None:
            """Внутренняя рекурсивная функция DFS"""
            # Помечаем вершину как посещённую
            visited[v] = True
            # Добавляем в результат
            order.append(v)
            # Рекурсивно обходим всех непосещённых соседей
            for u in self.neighbors(v):
                if not visited[u]:
                    _dfs(u)  # РЕКУРСИЯ — вызываем себя для соседа

        # Запускаем рекурсию от стартовой вершины
        _dfs(start)
        return order

    def dfs_iterative(self, start: int) -> List[int]:
        """
        Обход в глубину (DFS) — ИТЕРАТИВНАЯ версия (без рекурсии).
        
        Вместо рекурсии используем СТЕК (LIFO — последним пришёл, первым ушёл).
        Результат почти такой же, как у рекурсивного DFS.
        
        АЛГОРИТМ:
        1. Кладём стартовую вершину в стек
        2. Пока стек не пуст:
           - Берём вершину из верха стека (pop)
           - Если уже посещена — пропускаем
           - Помечаем как посещённую, записываем
           - Добавляем всех непосещённых соседей в стек
        
        Сложность: O(n + m)
        """
        if not (0 <= start < self.n):
            raise IndexError("start вне диапазона вершин")
        
        visited = [False] * self.n
        order: List[int] = []
        # Стек (используем обычный список Python)
        stack = [start]
        
        while stack:
            # Берём вершину с вершины стека (последнюю добавленную)
            v = stack.pop()
            # Если уже посещали — пропускаем
            if visited[v]:
                continue
            # Помечаем и записываем
            visited[v] = True
            order.append(v)
            
            # Добавляем соседей в стек
            # Добавляем в обратном порядке, чтобы порядок был как в рекурсивной версии
            neigh = self.neighbors(v)
            for u in reversed(neigh):
                if not visited[u]:
                    stack.append(u)
        
        return order

    def display(self) -> None:
        """Печать матрицы смежности в читаемом виде."""
        print("Матрица смежности:")
        for row in self.matrix:
            print(" ".join(str(x) for x in row))


if __name__ == "__main__":
    # Короткая демонстрация: неориентированный граф из 6 вершин
    mat = [
        [0, 1, 1, 0, 0, 0],
        [1, 0, 0, 1, 1, 0],
        [1, 0, 0, 0, 1, 0],
        [0, 1, 0, 0, 1, 1],
        [0, 1, 1, 1, 0, 0],
        [0, 0, 0, 1, 0, 0],
    ]
    g = Graph(mat, directed=False)
    g.display()
    print("\nBFS от вершины 0:", g.bfs(0))
    print("DFS (рекурсивный) от вершины 0:", g.dfs(0))
    print("DFS (итеративный) от вершины 0:", g.dfs_iterative(0))
