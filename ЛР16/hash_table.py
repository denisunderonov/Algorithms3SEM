"""
Хеш-таблица — структура данных для быстрого поиска, вставки и удаления.

ЧТО ТАКОЕ ХЕШ-ТАБЛИЦА?
Представь большой шкаф с пронумерованными ящиками (бакетами).
Когда нужно сохранить значение, мы:
1. Вычисляем для него "хеш" — числовой отпечаток
2. Определяем номер ящика: хеш % количество_ящиков
3. Кладём значение в этот ящик

КОЛЛИЗИИ — когда два значения попадают в один ящик.
Решение: в каждом ящике храним список (цепочку) значений.

ОПЕРАЦИИ:
- Вставка: O(1) в среднем — быстро находим ящик и добавляем
- Поиск: O(1) в среднем — быстро находим ящик и ищем в нём
- Удаление: O(1) в среднем — находим и удаляем из цепочки

Примеры использования есть в `interactive_hash.py`.
"""
from typing import Any, List, Tuple, Optional  # Подсказки типов для читаемости кода


class HashTable:
    """
    Хеш-таблица с разрешением коллизий методом цепочек (chaining).
    
    Как это работает:
    - Есть массив из N "бакетов" (ящиков)
    - Каждый бакет — список значений
    - Для каждого значения вычисляем хеш и определяем номер бакета
    - Если два значения попали в один бакет — они хранятся в списке вместе
    
    Пример: HashTable(size=5) для значений [7, 12, 17, 22]
    - 7  → hash(7)  % 5 = бакет 2 → table[2] = [7]
    - 12 → hash(12) % 5 = бакет 2 → table[2] = [7, 12]  (коллизия!)
    - 17 → hash(17) % 5 = бакет 2 → table[2] = [7, 12, 17]
    - 22 → hash(22) % 5 = бакет 2 → table[2] = [7, 12, 17, 22]
    """

    def __init__(self, size: int = 16):
        """
        Создание хеш-таблицы.
        
        Параметры:
            size: количество бакетов (ящиков) в таблице
                  Чем больше size, тем меньше коллизий, но больше памяти
        
        Пример: HashTable(size=10) создаст таблицу с 10 пустыми бакетами
        """
        # Проверяем корректность размера (должен быть положительным)
        if size <= 0:
            raise ValueError("size must be positive")
        
        # Сохраняем размер таблицы
        self.size = size
        
        # Создаём массив из size пустых списков (бакетов)
        # Каждый бакет изначально пуст: [[], [], [], ...]
        self.table: List[List[Any]] = [[] for _ in range(size)]

    def _hash(self, value: Any) -> int:
        """
        Вычисление номера бакета для значения (хеш-функция).
        
        Алгоритм:
        1. Используем встроенную функцию hash() — она даёт целое число для любого объекта
        2. Берём остаток от деления на size — получаем номер от 0 до size-1
        
        Пример: _hash(42) при size=10
        hash(42) может дать, например, 123456789
        123456789 % 10 = 9 — значение пойдёт в бакет №9
        """
        return hash(value) % self.size

    def insert(self, value: Any) -> Tuple[int, int]:
        """
        Вставка значения в хеш-таблицу.
        
        Алгоритм (простыми словами):
        1. Вычисляем, в какой бакет (ящик) положить значение
        2. Открываем этот бакет (он всегда существует)
        3. Добавляем значение в конец списка в этом бакете
        4. Возвращаем адрес: (номер бакета, позиция в списке)
        
        Сложность: O(1) — вычисление хеша и добавление в конец списка
        
        Пример: insert(42) при size=10
        → hash(42) % 10 = 2 (например)
        → table[2].append(42)
        → возвращаем (2, 0) если это первый элемент в бакете 2
        
        Возвращает: кортеж (номер_бакета, позиция_в_бакете)
        """
        # Шаг 1: Определяем номер бакета с помощью хеш-функции
        idx = self._hash(value)
        
        # Шаг 2: Получаем ссылку на список (бакет) с этим номером
        bucket = self.table[idx]
        
        # Шаг 3: Добавляем значение в конец списка
        bucket.append(value)
        
        # Шаг 4: Возвращаем позицию вставленного элемента
        # len(bucket) - 1 = индекс последнего элемента (только что добавленного)
        return idx, len(bucket) - 1

    def search_by_value(self, value: Any) -> List[Tuple[int, int]]:
        """
        Поиск всех вхождений значения в хеш-таблице.
        
        Алгоритм:
        1. Проходим по всем бакетам таблицы (от 0 до size-1)
        2. В каждом бакете проходим по всем элементам списка
        3. Если элемент равен искомому значению, запоминаем его позицию
        4. Возвращаем список всех найденных позиций
        
        Сложность: O(n) — нужно проверить все элементы во всех бакетах
        
        Почему не O(1)? Потому что одно значение может встретиться несколько раз
        в разных бакетах (если хеш-функция даёт разные результаты, например,
        для разных типов данных).
        
        Возвращает: список кортежей [(номер_бакета, позиция), ...]
        Если ничего не найдено, возвращает пустой список []
        """
        # Создаём пустой список для результатов
        results: List[Tuple[int, int]] = []
        
        # Проходим по всем бакетам таблицы с их номерами
        for i, bucket in enumerate(self.table):
            # Внутри каждого бакета проходим по элементам с их позициями
            for pos, v in enumerate(bucket):
                # Если нашли нужное значение
                if v == value:
                    # Добавляем в результаты позицию: (номер бакета, позиция в бакете)
                    results.append((i, pos))
        
        # Возвращаем все найденные позиции
        return results

    def search_by_index(self, index: int) -> List[Any]:
        """
        Получить все элементы из конкретного бакета.
        
        Это как открыть один ящик шкафа и посмотреть, что в нём лежит.
        
        Параметры:
            index: номер бакета (от 0 до size-1)
        
        Возвращает: копию списка элементов из этого бакета
        
        Сложность: O(k), где k — количество элементов в бакете
        
        Пример: search_by_index(2) вернёт все значения из бакета №2
        """
        # Проверяем: существует ли бакет с таким номером?
        if not (0 <= index < self.size):
            # Нет такого бакета — выбрасываем ошибку
            raise IndexError("bucket index out of range")
        
        # Возвращаем копию списка (чтобы внешний код не мог изменить оригинал)
        return list(self.table[index])

    def delete_by_value(self, value: Any) -> Optional[Tuple[int, int]]:
        """
        Удаление первого найденного вхождения значения.
        
        Алгоритм:
        1. Проходим по всем бакетам по порядку
        2. В каждом бакете ищем нужное значение
        3. Как только нашли — удаляем и сразу возвращаем позицию
        4. Если прошли все бакеты и ничего не нашли — возвращаем None
        
        Сложность: O(n) — в худшем случае проверяем все элементы
        
        Возвращает: (номер_бакета, позиция) или None
        """
        # Проходим по всем бакетам с их номерами
        for i, bucket in enumerate(self.table):
            # Внутри бакета ищем нужное значение
            for pos, v in enumerate(bucket):
                # Нашли! Удаляем и возвращаем позицию
                if v == value:
                    # Удаляем элемент из списка по позиции
                    del bucket[pos]
                    # Возвращаем, где он был
                    return (i, pos)
        
        # Ничего не нашли во всей таблице
        return None

    def delete_by_index(self, index: int, pos: Optional[int] = None) -> List[Any]:
        """
        Удаление элементов из конкретного бакета.
        
        Два режима работы:
        1. Если pos=None: удаляем ВСЁ из бакета (очищаем весь ящик)
        2. Если pos указан: удаляем только элемент на этой позиции
        
        Параметры:
            index: номер бакета
            pos: позиция элемента в бакете (None = удалить все)
        
        Возвращает: список удалённых элементов
        
        Примеры:
        - delete_by_index(2) — очистить весь бакет №2
        - delete_by_index(2, 0) — удалить первый элемент из бакета №2
        """
        # Проверяем корректность номера бакета
        if not (0 <= index < self.size):
            raise IndexError("bucket index out of range")
        
        # Получаем ссылку на бакет
        bucket = self.table[index]
        
        # Режим 1: Удалить всё из бакета
        if pos is None:
            # Сохраняем копию всех элементов, которые будем удалять
            removed = list(bucket)
            # Очищаем бакет (удаляем все элементы)
            bucket.clear()
            # Возвращаем то, что удалили
            return removed
        
        # Режим 2: Удалить один конкретный элемент
        # Проверяем: существует ли элемент на этой позиции?
        if not (0 <= pos < len(bucket)):
            raise IndexError("position out of range in bucket")
        
        # Удаляем элемент и получаем его значение
        item = bucket.pop(pos)
        # Возвращаем в виде списка (для единообразия с режимом 1)
        return [item]

    def display(self) -> None:
        """
        Вывести содержимое всей хеш-таблицы на экран.
        
        Удобно для отладки и понимания, как распределены элементы по бакетам.
        
        Формат вывода:
        0: [элементы в бакете 0]
        1: [элементы в бакете 1]
        ...
        
        Сложность: O(n) — проходим по всем элементам
        """
        # Проходим по всем бакетам с их номерами
        for i, bucket in enumerate(self.table):
            # Выводим: номер бакета и его содержимое
            print(f"{i}: {bucket}")


if __name__ == "__main__":
    # Короткий пример при запуске файла напрямую
    ht = HashTable(size=7)
    print("Вставляем: 10, 3, 24, 17, 31")
    for v in [10, 3, 24, 17, 31]:
        loc = ht.insert(v)
        print(f"Вставлено {v} -> бакет {loc[0]}, позиция {loc[1]}")
    print("Таблица:")
    ht.display()
    print("Поиск значения 24:", ht.search_by_value(24))
    print("Удаление по значению 3:", ht.delete_by_value(3))
    print("Таблица после удаления:")
    ht.display()
