"""Алгоритм Прима для поиска остова минимального веса (MST).

Реализован для графа, заданного матрицей смежности (взвешенный неориентированный граф).
Используется простой O(n^2) подход — подходящ для матрицы смежности и средних n.
"""
from typing import List, Tuple, Optional
import math


def prim(matrix: List[List[float]], start: int = 0) -> Tuple[List[Tuple[int, int, float]], float]:
    """
    Вычислить MST (Минимальное Остовное Дерево) алгоритмом Прима, начиная с вершины start.
    
    АЛГОРИТМ ПРИМА (простыми словами):
    1. Начинаем с одной вершины (start)
    2. На каждом шаге добавляем в MST самое лёгкое ребро,
       которое соединяет текущее дерево с новой вершиной
    3. Повторяем, пока не добавим все вершины
    
    ОТЛИЧИЕ ОТ КРАСКАЛА:
    - Краскал: сортируем ВСЕ рёбра и выбираем лучшие
    - Прим: растим дерево из одной точки, всегда расширяя его
    
    Сложность: O(n²) для матрицы смежности
    
    Возвращает (mst_edges, total_weight):
    - mst_edges: список рёбер MST в формате (u, v, вес)
    - total_weight: суммарный вес MST
    """
    # Проверка корректности матрицы
    if not matrix or any(len(row) != len(matrix) for row in matrix):
        raise ValueError("Матрица смежности должна быть квадратной и не пустой")
    
    # Количество вершин
    n = len(matrix)
    
    # Проверка стартовой вершины
    if not (0 <= start < n):
        raise IndexError("start вне диапазона вершин")

    # in_mst[i] = True означает "вершина i уже добавлена в MST"
    # Изначально все False — дерево пустое
    in_mst = [False] * n
    
    # key[i] — минимальный вес ребра, соединяющего i с текущим MST
    # Изначально все бесконечности (вершины не соединены с MST)
    key = [math.inf] * n
    
    # parent[i] — вершина в MST, от которой идёт минимальное ребро к i
    # Нужен для восстановления рёбер MST
    # None означает "нет родителя" (для стартовой вершины)
    parent: List[Optional[int]] = [None] * n

    # Инициализация: стартовая вершина — корень дерева
    # Её "стоимость подключения" = 0 (она уже есть)
    key[start] = 0.0

    # Главный цикл: добавляем вершины в MST по одной
    for _ in range(n):
        # ШАГ 1: Выбираем вершину с минимальным key среди не добавленных в MST
        # Это жадный выбор: берём самое дешёвое подключение
        u = -1  # номер выбранной вершины
        best = math.inf  # минимальный ключ
        
        for v in range(n):
            # Вершина подходит, если она:
            # 1) ещё не в MST (not in_mst[v])
            # 2) имеет меньший ключ, чем текущий лучший (key[v] < best)
            if not in_mst[v] and key[v] < best:
                best = key[v]
                u = v

        # Если не нашли вершину — граф несвязный
        if u == -1:
            break
        
        # Добавляем выбранную вершину u в MST
        in_mst[u] = True

        # ШАГ 2: Обновляем ключи соседей вершины u
        # Теперь u в дереве, проверяем все рёбра из u
        for v in range(n):
            # Получаем вес ребра u -> v
            w = matrix[u][v]
            
            # Обновляем ключ вершины v, если:
            # 1) ребро существует (w != 0)
            # 2) v ещё не в MST (not in_mst[v])
            # 3) вес ребра меньше текущего ключа v (w < key[v])
            if w and not in_mst[v] and w < key[v]:
                # Нашли более дешёвое подключение v к MST!
                key[v] = w  # обновляем минимальный вес
                parent[v] = u  # запоминаем, что лучшее ребро идёт от u

    # Восстанавливаем список рёбер MST из массива parent
    edges: List[Tuple[int, int, float]] = []
    total = 0.0
    
    # Проходим по всем вершинам (кроме start, у неё parent = None)
    for v in range(n):
        p = parent[v]
        # Если есть родитель — значит это ребро в MST
        if p is not None:
            # Получаем вес ребра p -> v
            w = matrix[p][v]
            # Добавляем ребро в список
            edges.append((p, v, w))
            # Увеличиваем общий вес
            total += w

    # Проверка связности: в дереве из n вершин должно быть n-1 ребро
    if len(edges) != n - 1:
        raise ValueError("Граф несвязный: MST не существует")

    # Возвращаем рёбра MST и общий вес
    return edges, total


def input_graph():
    """Интерактивный ввод неориентированного взвешенного графа."""
    print("=" * 50)
    print("ВВОД ГРАФА ДЛЯ АЛГОРИТМА ПРИМА (MST)")
    print("=" * 50)
    
    print("\n1 - Использовать пример графа (5 вершин)")
    print("2 - Ввести свой граф")
    choice = input("Выберите вариант (1 или 2): ").strip()
    
    if choice == "1":
        mat = [
            [0, 2, 0, 6, 0],
            [2, 0, 3, 8, 5],
            [0, 3, 0, 0, 7],
            [6, 8, 0, 0, 9],
            [0, 5, 7, 9, 0],
        ]
        print("\nИспользуется пример неориентированного взвешенного графа (5 вершин)")
        return mat
    
    # Ввод своего графа
    n = int(input("\nВведите количество вершин: "))
    
    print(f"\nВведите матрицу смежности {n}x{n} (веса рёбер)")
    print("  ВАЖНО: граф должен быть НЕОРИЕНТИРОВАННЫМ (симметричная матрица)")
    print("  0 = нет ребра")
    print("  положительное число = вес ребра")
    print("Пример для 3 вершин:")
    print("  0 4 2")
    print("  4 0 3")
    print("  2 3 0")
    print()
    
    mat = []
    for i in range(n):
        while True:
            try:
                row_input = input(f"Строка {i}: ").strip()
                row = list(map(float, row_input.split()))
                if len(row) != n:
                    print(f"  Ошибка: нужно ввести {n} чисел. Попробуйте снова.")
                    continue
                mat.append(row)
                break
            except ValueError:
                print("  Ошибка: введите числа через пробел. Попробуйте снова.")
    
    return mat


if __name__ == "__main__":
    print("ЛР19: АЛГОРИТМ ПРИМА - MST")
    print("-" * 50)
    
    # Граф из задания (неориентированный, взвешенный)
    # Рёбра: (0,1,1), (0,2,1), (0,3,4), (1,3,2), (2,3,2), (2,4,1), (3,4,1)
    
    mat = [
        [0, 1, 1, 4, 0],  # 0: с 1(1), с 2(1), с 3(4)
        [1, 0, 0, 2, 0],  # 1: с 0(1), с 3(2)
        [1, 0, 0, 2, 1],  # 2: с 0(1), с 3(2), с 4(1)
        [4, 2, 2, 0, 1],  # 3: с 0(4), с 1(2), с 2(2), с 4(1)
        [0, 0, 1, 1, 0],  # 4: с 2(1), с 3(1)
    ]
    
    n = len(mat)
    start = 0
    
    print(f"\nВыполнение алгоритма Прима (старт: вершина {start}):")
    
    try:
        edges, total = prim(mat, start=start)
        
        print("\nРёбра в минимальном остовном дереве:")
        for u, v, w in edges:
            print(f"  {u} — {v} (вес {w:.0f})")
        print(f"\nОбщий вес MST: {total:.0f}")
        
        print("\nПринцип:")
        print("  Растим дерево из стартовой вершины")
        print("  На каждом шаге добавляем ближайшую новую вершину")
        print("\nОтличие от Краскала:")
        print("  Краскал - смотрим на все рёбра, выбираем глобально лучшие")
        print("  Прим - растим дерево из точки, выбираем локально лучшие")
        
    except ValueError as e:
        print(f"\nОшибка: {e}")
    
    print()

