"""Алгоритм Краскала для поиска остова минимального веса (MST).

Работает для связного неориентированного взвешенного графа, заданного матрицей смежности.
Матрица: matrix[u][v] > 0 — вес ребра, matrix[u][v] == 0 — ребра нет.

Функция `kruskal(matrix)` возвращает кортеж (mst_edges, total_weight),
где mst_edges — список рёбер в формате (u, v, w) и total_weight — суммарный вес.
"""
from typing import List, Tuple


class UnionFind:
    """
    Система непересекающихся множеств (Disjoint Set Union, DSU).
    Используется для проверки связности и объединения компонент графа.
    
    Основные операции:
    - find(x) — найти представителя множества, к которому принадлежит x
    - union(a, b) — объединить множества, содержащие a и b
    """
    
    def __init__(self, n: int):
        """
        Инициализация DSU для n элементов (вершин).
        Изначально каждый элемент — отдельное множество.
        """
        # parent[i] — представитель (корень) множества элемента i
        # Изначально каждый элемент сам себе представитель
        # Например, для n=5: parent = [0, 1, 2, 3, 4]
        self.parent = list(range(n))
        
        # rank[i] — "ранг" (примерная высота) дерева с корнем i
        # Используется для оптимизации объединения
        # Изначально все ранги = 0 (деревья из одного узла)
        self.rank = [0] * n

    def find(self, x: int) -> int:
        """
        Найти представителя множества элемента x.
        С оптимизацией "сжатие пути" (path compression).
        
        ПРИМЕР: если элементы 5 -> 3 -> 1 (1 — корень)
        find(5) вернёт 1 и сделает 5 -> 1 напрямую (сжатие)
        """
        # Если x не является корнем своего дерева
        if self.parent[x] != x:
            # РЕКУРСИВНО находим корень и попутно сжимаем путь
            # Все узлы на пути к корню будут указывать прямо на корень
            # Это ускоряет последующие запросы
            self.parent[x] = self.find(self.parent[x])
        
        # Возвращаем корень (представителя множества)
        return self.parent[x]

    def union(self, a: int, b: int) -> bool:
        """
        Объединить множества, содержащие элементы a и b.
        С оптимизацией "объединение по рангу" (union by rank).
        
        Возвращает:
        - True, если множества были разными и объединение произошло
        - False, если a и b уже в одном множестве (объединять нечего)
        """
        # Находим представителей множеств элементов a и b
        ra = self.find(a)
        rb = self.find(b)
        
        # Если представители одинаковые — a и b уже в одном множестве
        # Объединение не требуется (добавление этого ребра создаст цикл!)
        if ra == rb:
            return False
        
        # ОБЪЕДИНЕНИЕ ПО РАНГУ:
        # Подвешиваем дерево с меньшим рангом к дереву с большим
        # Это сохраняет деревья более плоскими
        
        if self.rank[ra] < self.rank[rb]:
            # Дерево ra меньше — делаем rb его родителем
            self.parent[ra] = rb
        elif self.rank[ra] > self.rank[rb]:
            # Дерево rb меньше — делаем ra его родителем
            self.parent[rb] = ra
        else:
            # Ранги равны — подвешиваем rb к ra
            self.parent[rb] = ra
            # И увеличиваем ранг ra (дерево стало на уровень выше)
            self.rank[ra] += 1
        
        # Объединение успешно выполнено
        return True


def kruskal(matrix: List[List[float]]) -> Tuple[List[Tuple[int, int, float]], float]:
    """
    Вычислить MST (Минимальное Остовное Дерево) алгоритмом Краскала.
    
    АЛГОРИТМ КРАСКАЛА (простыми словами):
    1. Берём все рёбра графа и сортируем по весу (от меньшего к большему)
    2. Идём по отсортированным рёбрам:
       - Если ребро соединяет две разные компоненты — добавляем его в MST
       - Если ребро создаёт цикл (вершины уже связаны) — пропускаем
    3. Останавливаемся, когда добавили n-1 ребро (дерево готово)
    
    ЗАЧЕМ НУЖЕН MST?
    - Проложить дороги/кабели между городами с минимальной стоимостью
    - Кластеризация данных
    - Проектирование сетей
    
    Предполагается, что matrix — квадратная матрица.
    Для неориентированного графа матрица должна быть симметричной (или функция обработает u<v).
    
    Возвращает (mst_edges, total_weight):
    - mst_edges: список рёбер MST в формате (u, v, вес)
    - total_weight: суммарный вес всех рёбер MST
    """
    # Проверка корректности матрицы
    if not matrix or any(len(row) != len(matrix) for row in matrix):
        raise ValueError("Матрица смежности должна быть квадратной и не пустой")
    
    # Количество вершин в графе
    n = len(matrix)

    # ШАГ 1: Собрать все рёбра графа
    # Формат ребра: (вершина_1, вершина_2, вес)
    edges: List[Tuple[int, int, float]] = []
    
    # Проходим по верхней треугольной части матрицы (i < j)
    # Так мы берём каждое ребро только один раз (для неориентированного графа)
    for i in range(n):
        # j начинается с i+1, чтобы не брать диагональ и нижнюю часть
        for j in range(i + 1, n):
            # Получаем вес ребра между i и j
            w = matrix[i][j]
            # Если вес > 0 (ребро существует) — добавляем в список
            if w:
                edges.append((i, j, w))

    # ШАГ 2: Сортируем рёбра по возрастанию веса
    # key=lambda e: e[2] означает "сортировать по третьему элементу (вес)"
    # После сортировки: [(u1, v1, 1), (u2, v2, 2), (u3, v3, 3), ...]
    edges.sort(key=lambda e: e[2])

    # Создаём структуру Union-Find для отслеживания компонент связности
    # Она поможет проверять, создаст ли ребро цикл
    uf = UnionFind(n)
    
    # Список для хранения рёбер MST
    mst: List[Tuple[int, int, float]] = []
    
    # Суммарный вес MST
    total = 0.0

    # ШАГ 3: Проходим по отсортированным рёбрам (жадный выбор)
    for u, v, w in edges:
        # Пытаемся объединить вершины u и v
        # union вернёт True, если они были в разных компонентах (не было цикла)
        if uf.union(u, v):
            # Ребро не создаёт цикл — добавляем его в MST
            mst.append((u, v, w))
            # Прибавляем вес к общей сумме
            total += w
            
            # Проверяем: если добавили n-1 ребро — дерево готово
            # (остовное дерево для n вершин всегда содержит n-1 ребро)
            if len(mst) == n - 1:
                break  # Выходим из цикла раньше

    # Проверка связности графа:
    # Если добавили меньше n-1 рёбер — граф несвязный, MST не существует
    if len(mst) != n - 1:
        raise ValueError("Граф несвязный: MST не существует")

    # Возвращаем список рёбер MST и общий вес
    return mst, total


def input_graph():
    """Интерактивный ввод неориентированного взвешенного графа."""
    print("=" * 50)
    print("ВВОД ГРАФА ДЛЯ АЛГОРИТМА КРАСКАЛА (MST)")
    print("=" * 50)
    
    print("\n1 - Использовать пример графа (5 вершин)")
    print("2 - Ввести свой граф")
    choice = input("Выберите вариант (1 или 2): ").strip()
    
    if choice == "1":
        mat = [
            [0, 2, 0, 6, 0],
            [2, 0, 3, 8, 5],
            [0, 3, 0, 0, 7],
            [6, 8, 0, 0, 9],
            [0, 5, 7, 9, 0],
        ]
        print("\nИспользуется пример неориентированного взвешенного графа (5 вершин)")
        return mat
    
    # Ввод своего графа
    n = int(input("\nВведите количество вершин: "))
    
    print(f"\nВведите матрицу смежности {n}x{n} (веса рёбер)")
    print("  ВАЖНО: граф должен быть НЕОРИЕНТИРОВАННЫМ (симметричная матрица)")
    print("  0 = нет ребра")
    print("  положительное число = вес ребра")
    print("Пример для 3 вершин:")
    print("  0 4 2")
    print("  4 0 3")
    print("  2 3 0")
    print()
    
    mat = []
    for i in range(n):
        while True:
            try:
                row_input = input(f"Строка {i}: ").strip()
                row = list(map(float, row_input.split()))
                if len(row) != n:
                    print(f"  Ошибка: нужно ввести {n} чисел. Попробуйте снова.")
                    continue
                mat.append(row)
                break
            except ValueError:
                print("  Ошибка: введите числа через пробел. Попробуйте снова.")
    
    return mat


if __name__ == "__main__":
    print("ЛР19: АЛГОРИТМ КРАСКАЛА - MST")
    print("-" * 50)
    
    # Граф из задания (неориентированный, взвешенный)
    # Рёбра: (0,1,1), (0,2,1), (0,3,4), (1,3,2), (2,3,2), (2,4,1), (3,4,1)
    
    mat = [
        [0, 1, 1, 4, 0],  # 0: с 1(1), с 2(1), с 3(4)
        [1, 0, 0, 2, 0],  # 1: с 0(1), с 3(2)
        [1, 0, 0, 2, 1],  # 2: с 0(1), с 3(2), с 4(1)
        [4, 2, 2, 0, 1],  # 3: с 0(4), с 1(2), с 2(2), с 4(1)
        [0, 0, 1, 1, 0],  # 4: с 2(1), с 3(1)
    ]
    
    n = len(mat)
    print("     ", end="")
    for i in range(n):
        print(f"{i:4}", end="")
    print()
    for i in range(n):
        print(f"{i}: ", end="")
        for j in range(n):
            if mat[i][j] == 0:
                print("   -", end="")
            else:
                print(f"{mat[i][j]:4.0f}", end="")
        print()
    
    print("\nВыполнение алгоритма Краскала:")
    
    try:
        mst, total = kruskal(mat)
        
        # Показываем сортировку рёбер
        edges_all = []
        for i in range(n):
            for j in range(i + 1, n):
                if mat[i][j] > 0:
                    edges_all.append((i, j, mat[i][j]))
        edges_all.sort(key=lambda e: e[2])
        
        print("\nРёбра отсортированы по весу:")
        for u, v, w in edges_all:
            print(f"  {u}-{v} (вес {w:.0f})")
        
        print("\nРёбра в минимальном остовном дереве:")
        for u, v, w in mst:
            print(f"  {u} — {v} (вес {w:.0f})")
        print(f"\nОбщий вес MST: {total:.0f}")
        
        print("\nПринцип:")
        print("  Сортируем рёбра по весу, добавляем если не создают цикл")
        print("  Проверка цикла через Union-Find (система непересекающихся множеств)")
        
    except ValueError as e:
        print(f"\nОшибка: {e}")
    
    print()

