"""Реализация алгоритма Дейкстры для взвешенного ориентированного графа,
заданного взвешенной матрицей смежности.

Уточнение формата матрицы:
- `matrix[u][v]` > 0 — вес ребра u->v.
- `matrix[u][v] == 0` — ребра нет (кроме диагонали); нулевой вес ребра не поддерживается в этой учебной реализации.

API:
- `dijkstra(matrix, start)` -> (distances, prev)
    - distances: список минимальных расстояний от start до каждой вершины (float('inf') если недостижима).
    - prev: список предков для восстановления путей (None если нет предка).
- `reconstruct_path(prev, start, end)` -> список вершин пути start..end или пустой список если пути нет.

Все сообщения и докстринги на русском.
"""
from typing import List, Optional, Tuple
import math


def dijkstra(matrix: List[List[float]], start: int) -> Tuple[List[float], List[Optional[int]]]:
    """Выполнить алгоритм Дейкстры для матрицы смежности.

    Параметры:
    - matrix: квадратная матрица (список списков). matrix[u][v] > 0 означает вес ребра u->v.
    - start: индекс стартовой вершины (0..n-1).

    Возвращает (distances, prev):
    - distances[i] — минимальное расстояние от start до i (float('inf') если недостижимо).
    - prev[i] — предыдущая вершина на кратчайшем пути к i (None если нет предка или i == start).
    """
    # Проверка: матрица должна быть квадратной и не пустой
    # Если хоть одна строка имеет другую длину — это ошибка
    if not matrix or any(len(row) != len(matrix) for row in matrix):
        raise ValueError("Матрица смежности должна быть квадратной и не пустой")
    
    # Запоминаем количество вершин в графе
    n = len(matrix)
    
    # Проверяем, что стартовая вершина существует
    if not (0 <= start < n):
        raise IndexError("start вне диапазона вершин")

    # Массив расстояний от стартовой вершины до каждой вершины
    # Изначально все расстояния = бесконечность (вершины недостижимы)
    # math.inf — это специальное значение "бесконечность"
    dist: List[float] = [math.inf] * n
    
    # Массив предков для восстановления пути
    # prev[i] хранит вершину, из которой мы пришли в i по кратчайшему пути
    # Изначально все None (предков нет)
    prev: List[Optional[int]] = [None] * n
    
    # Массив посещённых вершин (уже обработанных)
    # visited[i] = True означает "для вершины i найдено минимальное расстояние"
    visited: List[bool] = [False] * n

    # Расстояние от стартовой вершины до себя = 0
    # Это база алгоритма: мы начинаем отсюда
    dist[start] = 0.0

    # Главный цикл алгоритма Дейкстры
    # Повторяем n раз — по разу для каждой вершины
    for _ in range(n):
        # ШАГ 1: Выбираем непосещённую вершину с минимальным расстоянием
        # Это жадная стратегия: берём ближайшую из доступных
        u = -1  # номер выбранной вершины (-1 = пока не выбрана)
        best = math.inf  # минимальное расстояние (изначально бесконечность)
        
        # Перебираем все вершины и ищем лучшую
        for i in range(n):
            # Вершина подходит, если:
            # 1) она ещё не посещена (not visited[i])
            # 2) её расстояние меньше текущего лучшего (dist[i] < best)
            if not visited[i] and dist[i] < best:
                best = dist[i]  # обновляем лучшее расстояние
                u = i  # запоминаем эту вершину

        # Если не нашли подходящую вершину (u == -1)
        # значит все оставшиеся вершины недостижимы
        # Алгоритм завершён досрочно
        if u == -1:
            break

        # Помечаем выбранную вершину как посещённую
        # Для неё уже найдено минимальное расстояние, больше не трогаем
        visited[u] = True

        # ШАГ 2: РЕЛАКСАЦИЯ рёбер (обновление расстояний)
        # Смотрим все исходящие рёбра из вершины u
        for v in range(n):
            # Получаем вес ребра u -> v
            w = matrix[u][v]
            
            # Если w != 0, значит ребро существует
            if w:
                # Проверяем: можем ли улучшить путь до вершины v?
                # Новый путь: идём до u (dist[u]) + ребро u->v (w)
                # Если это меньше текущего расстояния до v — обновляем
                if dist[u] + w < dist[v]:
                    # Нашли более короткий путь до v!
                    dist[v] = dist[u] + w  # обновляем расстояние
                    prev[v] = u  # запоминаем, что пришли из u

    # Возвращаем результат: массивы расстояний и предков
    return dist, prev


def reconstruct_path(prev: List[Optional[int]], start: int, end: int) -> List[int]:
    """Восстановить путь из start в end по массиву prev.

    Возвращает список вершин от start до end включительно, или пустой список если пути нет.
    """
    # Список для хранения пути (будет заполняться в обратном порядке)
    path: List[int] = []
    
    # Начинаем с конечной вершины
    cur = end
    
    # Идём назад по цепочке предков, пока не дойдём до начала
    while cur is not None:
        # Добавляем текущую вершину в путь
        path.append(cur)
        
        # Если дошли до стартовой вершины — путь построен
        if cur == start:
            break
        
        # Переходим к предку текущей вершины
        # prev[cur] содержит вершину, из которой мы пришли в cur
        cur = prev[cur]

    # Проверяем корректность пути:
    # Если путь пустой ИЛИ последний элемент не start — пути не существует
    # (означает, что мы не дошли до стартовой вершины)
    if not path or path[-1] != start:
        return []  # возвращаем пустой список
    
    # Разворачиваем путь, т.к. собирали в обратном порядке (end -> start)
    # reverse() меняет порядок элементов на противоположный (start -> end)
    path.reverse()
    
    # Возвращаем готовый путь от start до end
    return path


def input_graph():
    """Интерактивный ввод взвешенного графа."""
    print("=" * 50)
    print("ВВОД ВЗВЕШЕННОГО ГРАФА ДЛЯ АЛГОРИТМА ДЕЙКСТРЫ")
    print("=" * 50)
    
    print("\n1 - Использовать пример графа (6 вершин)")
    print("2 - Ввести свой граф")
    choice = input("Выберите вариант (1 или 2): ").strip()
    
    if choice == "1":
        # Пример из кода
        mat = [
            [0, 7, 9, 0, 0, 14],
            [0, 0, 10, 15, 0, 0],
            [0, 0, 0, 11, 0, 2],
            [0, 0, 0, 0, 6, 0],
            [0, 0, 0, 0, 0, 9],
            [0, 0, 0, 0, 0, 0],
        ]
        print("\nИспользуется пример взвешенного ориентированного графа (6 вершин)")
        return mat
    
    # Ввод своего графа
    n = int(input("\nВведите количество вершин: "))
    
    print(f"\nВведите матрицу смежности {n}x{n} (веса рёбер)")
    print("  0 = нет ребра")
    print("  положительное число = вес ребра")
    print("Пример для 3 вершин:")
    print("  0 5 0")
    print("  0 0 3")
    print("  0 0 0")
    print()
    
    mat = []
    for i in range(n):
        while True:
            try:
                row_input = input(f"Строка {i}: ").strip()
                row = list(map(float, row_input.split()))
                if len(row) != n:
                    print(f"  Ошибка: нужно ввести {n} чисел. Попробуйте снова.")
                    continue
                mat.append(row)
                break
            except ValueError:
                print("  Ошибка: введите числа через пробел. Попробуйте снова.")
    
    return mat


if __name__ == "__main__":
    print("ЛР18: АЛГОРИТМ ДЕЙКСТРЫ")
    print("-" * 50)
    
    # Граф из задания (НЕОРИЕНТИРОВАННЫЙ, для поиска кратчайшего пути 0→3)
    # Рёбра: 0-1(1), 0-2(1), 0-3(4), 1-3(2), 2-3(2), 2-4(1), 3-4(1)
    
    mat = [
        [0, 1, 1, 4, 0],  # 0: с 1(1), с 2(1), с 3(4)
        [1, 0, 0, 2, 0],  # 1: с 0(1), с 3(2)
        [1, 0, 0, 2, 1],  # 2: с 0(1), с 3(2), с 4(1)
        [4, 2, 2, 0, 1],  # 3: с 0(4), с 1(2), с 2(2), с 4(1)
        [0, 0, 1, 1, 0],  # 4: с 2(1), с 3(1)
    ]
    
    n = len(mat)
    print(f"\n{'=' * 70}")
    print("МАТРИЦА ВЕСОВ")
    print("=" * 70)
    print("     ", end="")
    for i in range(n):
        print(f"{i:4}", end="")
    print()
    for i in range(n):
        print(f"{i}: ", end="")
        for j in range(n):
            if mat[i][j] == 0:
                print("   -", end="")
            else:
                print(f"{mat[i][j]:4.0f}", end="")
        print()
    
    start = 0
    
    print(f"\nПоиск кратчайших путей из вершины {start}:")
    dist, prev = dijkstra(mat, start)
    
    print("\nКратчайшие расстояния:")
    for v in range(n):
        if dist[v] == math.inf:
            print(f"  до вершины {v}: недостижима")
        else:
            print(f"  до вершины {v}: {dist[v]:.0f}")
    
    # Восстановление пути от 0 до 3 (по заданию)
    target = 3
    if dist[target] != math.inf:
        path = reconstruct_path(prev, start, target)
        if path:
            print(f"\nКратчайший путь от {start} до {target}:")
            print(f"  {' -> '.join(map(str, path))} (длина {dist[target]:.0f})")
            print(f"\nОбъяснение: оптимальный маршрут {start}→1→{target} дешевле, чем прямой путь {start}→{target}")
    
    print("\nПринцип:")
    print("  На каждом шаге выбираем вершину с минимальным расстоянием")
    print("  Обновляем расстояния до соседей: dist[v] = min(dist[v], dist[u] + вес)")
    print("  Работает только для графов БЕЗ отрицательных весов")
    print()
